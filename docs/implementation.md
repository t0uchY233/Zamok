# План реализации следующего этапа проекта "Замок"

В этом документе описаны шаги по реализации следующего этапа развития проекта **"Замок"** на основе результатов предыдущего отчета и новых требований. Основная цель текущего этапа – заменить интеграцию с Google Sheets на интеграцию с **Airtable API**, так как пользователь перенес таблицу бронирований из Google Sheets в Airtable. Также запланированы сопутствующие изменения в коде и подготовка к будущему обновлению UI. Ниже приводится подробный план работ.

## Задача 1. Интеграция с Airtable API вместо Google Sheets

**Цель:** Настроить подключение к Airtable и использовать его API для сохранения данных о бронированиях, заменив прежнюю интеграцию с Google Sheets.

- [ ] **Добавление ключа API Airtable в конфигурацию:** В файле переменных окружения `.env` необходимо добавить новый API-ключ Airtable. Пользователь уже создал API-ключ: `patbjUfXERF0ByXKk.7e6c3c9a535cbfeec30b1150b0f29f76a20e237cc257f6af1af8285e2c609a22`. Рекомендуется сохранить его в переменной, например `AIRTABLE_API_KEY`, и **не** хардкодить ключ в исходном коде для безопасности.
- [ ] **Настройка идентификаторов Airtable:** Определить идентификатор базы Airtable и название (или идентификатор) таблицы, в которой будут храниться бронирования. Эти значения можно получить через интерфейс Airtable (раздел API documentation для соответствующей базы). Добавить их в конфигурацию, например `AIRTABLE_BASE_ID` (начинается с `app...`) и `AIRTABLE_TABLE_NAME` (например, `Bookings` или соответствующее имя таблицы). Эти параметры понадобятся для формирования запросов к Airtable API.
- [ ] **Обновление настроек приложения:** Убедиться, что новые переменные окружения загружаются при запуске приложения. Если используется библиотека вроде python-dotenv, обновить `.env` и перезапустить приложение, чтобы переменные `AIRTABLE_API_KEY`, `AIRTABLE_BASE_ID` и `AIRTABLE_TABLE_NAME` были доступны модулю интеграции. Также можно внести их в файл конфигурации Flask-приложения, если такой имеется.
- [ ] **Планирование замены логики сохранения данных:** Проанализировать текущую логику добавления бронирования (функция `add_booking_to_sheet` в `app/sheets_integration.py`). Новая интеграция должна осуществлять аналогичные действия (формирование данных и сохранение), но через вызов Airtable API. Запланировать реализацию нового модуля (см. Задачу 3) и обновление функции обработки бронирования в маршрутах (см. Задачу 2 и 3). 

> **Примечание:** Airtable API предоставляет REST-интерфейс для работы с записями. Мы будем использовать метод **POST** к эндпоинту `https://api.airtable.com/v0/<BASE_ID>/<TableName>` для добавления новой записи. Аутентификация выполняется с помощью заголовка `Authorization: Bearer <API_KEY>`. Формат тела запроса – JSON с ключом `"fields"`, содержащим словарь полей и значений бронирования.

## Задача 2. Удаление устаревшей интеграции с Google Sheets

**Цель:** Очистить проект от старого кода, связанного с Google Sheets, чтобы избежать конфликтов и поддерживать кодовую базу в актуальном состоянии.

- [ ] **Удалить модуль интеграции с Google Sheets:** Удалить файл `app/sheets_integration.py`, так как он больше не понадобится. В предыдущем отчете отмечалось, что интеграция с Google Sheets была реализована, но требовала обновления ключей; теперь вместо этого будет использоваться Airtable.
- [ ] **Удалить вызовы Google Sheets из маршрутов:** Открыть файл `app/routes.py` и найти места, где используется старый модуль. В частности, необходимо удалить (или закомментировать) импорт: 

  ```python
  from app.sheets_integration import add_booking_to_sheet
  ``` 

  и вызов функции `add_booking_to_sheet(booking_data)`. Эти строчки коде больше не нужны и будут заменены на вызовы нового модуля Airtable. Также следует удалить обработку ошибок/логирование, специфичные для Google Sheets (например, сообщения о проблемах с Google Sheets), либо обновить их под новую интеграцию.
- [ ] **Обновить зависимости (при необходимости):** Если в `requirements.txt` были указаны библиотеки для работы с Google Sheets (например, `gspread` или Google API Client), и они больше не используются, их можно удалить из зависимостей проекта. Также можно удалить файл сервисного аккаунта Google API (`quick-flame-...json`), если он не нужен для других частей проекта.
- [ ] **Проверить остальные части проекта:** Убедиться, что больше нигде в кодовой базе не осталось ссылок на Google Sheets. Например, в конфигурации (`.env`) можно убрать переменную `SPREADSHEET_ID` и другие параметры, связанные с Google API, чтобы избежать путаницы. Теперь источником данных бронирований будет Airtable.

После выполнения этой задачи проект не будет содержать упоминаний о Google Sheets, paving the way (подготовив почву) для интеграции с Airtable.

## Задача 3. Реализация модуля интеграции с Airtable

**Цель:** Создать новый модуль для взаимодействия с Airtable API и обеспечить сохранение данных о бронированиях в Airtable по аналогии с тем, как это ранее делалось в Google Sheets.

- [ ] **Создать модуль `app/airtable_integration.py`:** В каталоге `app/` создайте новый файл `airtable_integration.py`. В этом модуле будет функция для добавления записи о бронировании в Airtable. Для удобства можно также определить необходимые конфигурационные константы или получить их из окружения.

- [ ] **Реализовать функцию добавления бронирования:** Напишите функцию, например `add_booking_to_airtable(booking_data)`, которая принимает данные бронирования и выполняет запрос к Airtable API для сохранения этих данных. Функция должна возвращать True при успешной записи и False при ошибке (по аналогии с прежней реализацией).

**Пример содержимого нового модуля `app/airtable_integration.py`:**

```python
import os
import logging
import requests

# Получаем конфигурацию из переменных окружения
AIRTABLE_API_KEY = os.environ.get("AIRTABLE_API_KEY")
AIRTABLE_BASE_ID = os.environ.get("AIRTABLE_BASE_ID")
AIRTABLE_TABLE_NAME = os.environ.get("AIRTABLE_TABLE_NAME")

logger = logging.getLogger(__name__)  # Логгер для данного модуля

def add_booking_to_airtable(booking_data):
    """Добавляет данные о бронировании в Airtable."""
    try:
        # Формируем заголовки и URL для запроса
        url = f"https://api.airtable.com/v0/{AIRTABLE_BASE_ID}/{AIRTABLE_TABLE_NAME}"
        headers = {
            "Authorization": f"Bearer {AIRTABLE_API_KEY}",
            "Content-Type": "application/json"
        }
        # Подготавливаем данные полей бронирования для отправки в Airtable
        fields = {
            "ID": booking_data.get("id"),
            "Name": booking_data.get("name"),
            "Apartment": booking_data.get("apartment_name"),
            "CheckIn": booking_data.get("check_in_date"),
            "CheckOut": booking_data.get("check_out_date"),
            "Price": booking_data.get("formatted_price"),
            "Status": booking_data.get("status"),
            "Timestamp": booking_data.get("current_time")
        }
        payload = {"fields": fields}
        logger.info(f"Отправка данных бронирования в Airtable: {fields}")
        # Выполняем POST-запрос к Airtable API
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()  # выбросит исключение при ошибке HTTP
        logger.info("Данные успешно записаны в Airtable")
        return True
    except Exception as e:
        logger.error(f"Ошибка при добавлении данных в Airtable: {e}")
        return False
```

В приведенном примере кода:
  - Используется модуль `requests` для отправки HTTP-запроса. Убедитесь, что `requests` добавлен в `requirements.txt`, если он еще не был в зависимостях.
  - Данные бронирования (`booking_data`) предполагается передавать в виде словаря с ключами, соответствующими нужным полям. Эти поля (ID, Name, Apartment, CheckIn, CheckOut, Price, Status, Timestamp) должны точно совпадать с названиями колонок в таблице Airtable. При необходимости замените названия (`"CheckIn"`, `"CheckOut"`, etc.) на те, которые используются в базе Airtable (например, если колонка называется "Check-in Date", нужно указать точно такое имя).
  - Логирование используется для отладки: информация о отправляемых данных и сообщение об успешной записи или об ошибке.
  - В случае неуспеха `response.raise_for_status()` вызовет исключение, которое мы ловим, логируем ошибку и возвращаем False.

- [ ] **Интегрировать новый модуль в маршруты приложения:** Теперь необходимо использовать функцию `add_booking_to_airtable` в обработчике бронирования. В файле `app/routes.py` заменить использование старой функции на новую. Например, в маршруте `/api/submit-quote` должно быть:

  ```python
  from app.airtable_integration import add_booking_to_airtable
  ...
  # Вместо add_booking_to_sheet(booking_data):
  result = add_booking_to_airtable(booking_data)
  if result:
      app.logger.info(f"Бронирование №{booking_id} успешно сохранено в Airtable")
      return jsonify({
          "success": True,
          "booking_id": booking_id,
          "message": "Бронирование успешно создано"
      })
  else:
      app.logger.error("Ошибка при записи бронирования в Airtable")
      return jsonify({
          "success": False,
          "error": "Ошибка при создании бронирования (проблема с сохранением данных)"
      }), 500
  ```
  
  В этом фрагменте показано, как заменить импорт и вызов функции:
  - Импортируется `add_booking_to_airtable` из нового модуля вместо старого `add_booking_to_sheet`.
  - Вызывается `add_booking_to_airtable(booking_data)` и проверяется результат.
  - Логирование и сообщения об ошибках обновлены: теперь они упоминают Airtable, а не Google Sheets. Обратите внимание, что текст ошибки для клиента изменен на общее описание проблемы с сохранением данных, без указания внутренней системы (можно упомянуть Airtable, но пользователю конечному это не обязательно знать).

- [ ] **Проверить работу новой интеграции:** После внесения изменений перезапустите приложение и протестируйте создание бронирования. Убедитесь, что при отправке формы бронирования:
    - Сервер логирует попытку сохранения в Airtable и не выдает ошибок в консоли.
    - В Airtable в указанной базе и таблице появляется новая запись с корректными данными (ID, имя пользователя, квартира, даты, цена, статус, временная метка).
    - Клиентское приложение получает ответ `"success": True` и отображает сообщение об успешном бронировании, а в тексте подтверждения фигурирует номер бронирования (`booking_id`).
  
  Если возникают ошибки, использовать сообщения логов и ответ сервера для отладки (например, проверить правильность Base ID, имени таблицы, наличия необходимых прав API-ключа и совпадения названий полей). После успешного тестирования можно считать миграцию на Airtable завершенной для серверной части.

## Следующий этап: Переход UI на Shadcn/UI и Tailwind CSS

После успешной замены интеграции на стороне backend, следующим шагом запланировано обновление пользовательского интерфейса приложения с использованием современного стека технологий для UI:

- **Переход на дизайн-систему Shadcn/UI:** Планируется внедрить библиотеку компонентов [Shadcn/UI](https://ui.shadcn.com) для унификации и ускорения разработки интерфейса. Shadcn/UI предлагает набор готовых, настраиваемых компонентов на основе React + Radix UI, что позволит создать современный и консистентный внешний вид приложения.
- **Интеграция [Tailwind CSS](https://tailwindcss.com/):** В рамках перехода на новую UI-систему будет использоваться Tailwind CSS для стилизации компонентов. Tailwind CSS – утилитарный CSS-фреймворк, который хорошо сочетается с Shadcn/UI. Необходимо будет настроить Tailwind в проекте (если еще не настроен): добавить файлы конфигурации `tailwind.config.js`, подключить директивы Tailwind в CSS, и обеспечить сборку стилей (например, через PostCSS или соответствующий билд-процесс).
- **Обновление компонентов интерфейса:** Существующий фронтенд (HTML/JS/CSS) потребуется адаптировать под новые компоненты. Это может включать замену стандартных элементов форм и кнопок на компоненты из Shadcn/UI, а также рефакторинг структуры страниц с учетом предлагаемых шаблонов/блоков. Важным аспектом будет обеспечение responsive-дизайна и доступности (a11y), что упрощается благодаря готовым решениям в Shadcn/UI.
- **Использование возможностей Cursor IDE:** Разработка UI будет выполняться с помощью современных инструментов. В частности, планируется задействовать возможности [Cursor IDE](https://www.cursor.com/) (интеллектуальной среды разработки с AI-помощником) для ускорения верстки и внедрения компонентов. Cursor IDE может помочь в генерации типового кода компонентов и быстром применении стилей Tailwind по описанию на естественном языке, что повысит эффективность работы над новым интерфейсом.
- **Планирование и обучение:** Переход на новую дизайн-систему затронет многие части проекта, поэтому целесообразно спланировать этот этап отдельно. Следует ознакомиться с документацией Shadcn/UI и Tailwind CSS, подготовить примеры компонентов, протестировать их интеграцию в небольшом участке приложения, а затем последовательно внедрять по модулям/страницам. Этот этап может быть оформлен отдельным планом миграции UI с перечнем компонентов для замены и задач по стилизации.

**Ожидаемый результат следующего этапа:** обновленный пользовательский интерфейс, реализованный на базе Shadcn/UI компонентов и стилизованный с помощью Tailwind CSS, что придаст приложению современный вид и улучшит опыт взаимодействия пользователя. Этот рефакторинг UI будет выполнен после завершения текущей серверной задачи и обеспечит целостное обновление проекта "Замок" на всех уровнях (backend и frontend).